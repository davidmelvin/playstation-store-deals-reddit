package main

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/gocolly/colly"
	"github.com/mitchellh/mapstructure"
)

const productURLPrefix = "https://store.playstation.com/en-us/product/"
const testingURL = "https://store.playstation.com/en-us/category/99369cc3-0ac2-46de-b437-e8c70c79f55e"

type ProductData struct {
	ProductMap map[string]Product
	PriceMap   map[string]SkuPrice
}

func getProductDataFromJSONStrings(pages []string) ProductData {
	productMap := make(map[string]Product)
	priceMap := make(map[string]SkuPrice)
	for _, page := range pages {
		var data AutoGenerated
		json.Unmarshal([]byte(page), &data)

		for k, v := range data.Props.ApolloState {
			apolloStateData, ok := v.(map[string]interface{})
			if !ok {
				fmt.Println("apollo state data is not a map[string]interface{}")
			}
			switch apolloStateData["__typename"] {

			case "Product":
				var product Product
				if err := mapstructure.Decode(apolloStateData, &product); err != nil {
					fmt.Println("could not decode appollo state data as a product")
				}
				productMap[product.ID] = product

			case "SkuPrice":
				var price SkuPrice
				if err := mapstructure.Decode(apolloStateData, &price); err != nil {
					fmt.Println("could not decode appollo state data as a price")
				}

				// not ideal hardcode, but k should be of form: $Product:UP9000-CUSA17357_00-STB0670000000000:en-us.price
				// TODO: consider how to make this less fragile
				productID := strings.Split(k, ":")[1]
				price.ProductID = productID

				priceMap[productID] = price

			}
		}
	}

	var productData ProductData
	productData.ProductMap = productMap
	productData.PriceMap = priceMap
	return productData
}

func main() {
	pages := scrape()
	productData := getProductDataFromJSONStrings(pages)
	fmt.Printf("There are %d products and %d prices\n", len(productData.ProductMap), len(productData.PriceMap))
	if len(productData.ProductMap) != len(productData.PriceMap) {
		fmt.Println("we don't have exactly one price for each product")
	}
	// fmt.Println(productData.getTable())
}

func scrape() []string {
	pageNumber := 1
	var jsonBodies []string
	c := colly.NewCollector(
		colly.AllowedDomains("store.playstation.com"),
	)

	c.OnRequest(func(r *colly.Request) {
		fmt.Println("Visiting: ", r.URL.String())
	})
	c.Limit(&colly.LimitRule{
		Delay:       3 * time.Second,
		RandomDelay: 5 * time.Second,
	})

	c.OnHTML("#__NEXT_DATA__", func(e *colly.HTMLElement) {
		fmt.Println("found next.js data! Will add it to the list...")
		jsonBodies = append(jsonBodies, e.Text)
	})

	c.OnHTML(`button[data-qa="ems-sdk-grid-paginator-next-page-btn"]`, func(e *colly.HTMLElement) {
		fmt.Println("found a next page button! Checking if it's disabled.")
		buttonIsDisabled := false
		for _, node := range e.DOM.Nodes {
			for _, attr := range node.Attr {
				if attr.Key == "disabled" {
					fmt.Println("Found disabled next button. Will stop here")
					buttonIsDisabled = true
					break
				}
			}
		}
		if !buttonIsDisabled {
			fmt.Printf("next page button is not disabled.  Visiting to next page: #%d\n", pageNumber+1)
			pageNumber++
			c.Visit(fmt.Sprintf("%s/%d", testingURL, pageNumber))
		}
	})

	c.Visit(fmt.Sprintf("%s/%d", testingURL, pageNumber))

	return jsonBodies
}

// TODO: sorted aphabetically or by price? currently there is no guarantee on ordering
// TODO: include PS plus vs not ps plus?
// TODO: what is the biggest comment we can make in a reddit comment?
func (productData *ProductData) getTable() string {
	// TODO: tie top row order to getProductRow return order to make less fragile
	topRow := "Title | Discounted price | % Off | Regular Price\n"
	alignmentRow := ":--|:--|:--|:--\n"

	var productRows []string
	for _, product := range productData.ProductMap {
		productRows = append(productRows, productData.getProductRow(product))
	}

	productRowsString := strings.Join(productRows, "\n")

	return topRow + alignmentRow + productRowsString
}

func (productData *ProductData) getProductRow(product Product) string {
	priceData := productData.PriceMap[product.ID]

	hyperlinkedName := fmt.Sprintf("[%s](%s)", product.Name, productURLPrefix+product.ID)

	// make sure this isn't fragile. possibly no guarantees
	discountedPrice := priceData.DiscountedPrice
	discountPercentage, ok := priceData.DiscountText.(string)
	if !ok {
		discountPercentage = "0%"
	}
	basePrice := priceData.BasePrice
	return fmt.Sprintf("%s | %s | %s | %s", hyperlinkedName, discountedPrice, discountPercentage, basePrice)
}
