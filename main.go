package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/mitchellh/mapstructure"
)

type ProductData struct {
	Products []Product
	Prices   []SkuPrice
}

func getProductData() ProductData {
	var productData ProductData

	jsonFile, err := os.Open("examples/data2.json")
	if err != nil {
		fmt.Println("error opening JSON file: ", err)
	}
	defer jsonFile.Close()

	jsonBytes, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		fmt.Println("error reading JSON bytes: ", err)
	}

	var data AutoGenerated

	json.Unmarshal(jsonBytes, &data)
	var products []Product
	var prices []SkuPrice
	for k, v := range data.Props.ApolloState {
		apolloStateData, ok := v.(map[string]interface{})
		if !ok {
			fmt.Println("apollo state data is not a map[string]interface{}")
		}
		switch apolloStateData["__typename"] {

		case "Product":
			var product Product
			if err := mapstructure.Decode(apolloStateData, &product); err != nil {
				fmt.Println("could not decode appollo state data as a product")
			}

			// fmt.Printf("product k: %+v\n", k)
			// fmt.Printf("product: %+v\n", product)

			products = append(products, product)

		case "SkuPrice":
			var price SkuPrice
			if err := mapstructure.Decode(apolloStateData, &price); err != nil {
				fmt.Println("could not decode appollo state data as a price")
			}
			price.ProductID = k
			// fmt.Printf("price k: %+v\n", k)

			// fmt.Printf("price: %+v\n", price)

			prices = append(prices, price)
		}
	}

	productData.Products = products
	productData.Prices = prices
	return productData
}

func main() {

	productData := getProductData()
	fmt.Printf(productData.getTable())

	// fmt.Printf("there are %d products\n", len(products))
	// fmt.Printf("there are %d prices\n", len(prices))

	// fmt.Printf("product: %+v\n", products[0])
	// fmt.Printf("price: %+v\n", prices[0])
}

func (productData *ProductData) getTable() string {
	topRow := "Title | %% Off | Discounted price | Regular Price\n"
	alignmentRow := ":--|:--|:--|:--\n"

	var productRows []string
	for _, product := range productData.Products {
		productRows = append(productRows, productData.getProductRow(product))
	}

	strings.Join(productRows, "")

	return fmt.Sprintf("%s%s%s", topRow, alignmentRow, productRows)
}

// name, price, % off, regular price
// TODO: is there a better way to architect the data here to avoid copying structs over and over?
func (productData *ProductData) getProductRow(product Product) string {
	return fmt.Sprintf("%s|%s|%s|%s\n", product.Name, "price", "percent off", "original price")
}
