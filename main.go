package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/mitchellh/mapstructure"
)

type ProductData struct {
	ProductMap map[string]Product
	PriceMap   map[string]SkuPrice
}

func getProductData() ProductData {
	var productData ProductData

	jsonFile, err := os.Open("examples/data2.json")
	if err != nil {
		fmt.Println("error opening JSON file: ", err)
	}
	defer jsonFile.Close()

	jsonBytes, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		fmt.Println("error reading JSON bytes: ", err)
	}

	var data AutoGenerated
	json.Unmarshal(jsonBytes, &data)

	productMap := make(map[string]Product)
	priceMap := make(map[string]SkuPrice)

	for k, v := range data.Props.ApolloState {
		apolloStateData, ok := v.(map[string]interface{})
		if !ok {
			fmt.Println("apollo state data is not a map[string]interface{}")
		}
		switch apolloStateData["__typename"] {

		case "Product":
			var product Product
			if err := mapstructure.Decode(apolloStateData, &product); err != nil {
				fmt.Println("could not decode appollo state data as a product")
			}
			productMap[product.ID] = product

		case "SkuPrice":
			var price SkuPrice
			if err := mapstructure.Decode(apolloStateData, &price); err != nil {
				fmt.Println("could not decode appollo state data as a price")
			}

			// not ideal hardcode, but k should be of form: $Product:UP9000-CUSA17357_00-STB0670000000000:en-us.price
			// TODO: consider how to make this less fragile
			productID := strings.Split(k, ":")[1]
			price.ProductID = productID

			priceMap[productID] = price

		}
	}

	productData.ProductMap = productMap
	productData.PriceMap = priceMap
	return productData
}

func main() {
	productData := getProductData()
	fmt.Printf("There are %d products and %d prices\n", len(productData.ProductMap), len(productData.PriceMap))
	if len(productData.ProductMap) != len(productData.PriceMap) {
		fmt.Println("we don't have exactly one price for each product")
	}
	fmt.Println(productData.getTable())
}

// TODO: sorted aphabetically or by price? currently there is no guarantee on ordering
func (productData *ProductData) getTable() string {
	// TODO: tie top row order to getProductRow return order to make less fragile
	topRow := "Title | Discounted price | % Off | Regular Price\n"
	alignmentRow := ":--|:--|:--|:--\n"

	var productRows []string
	for _, product := range productData.ProductMap {
		productRows = append(productRows, productData.getProductRow(product))
	}

	productRowsString := strings.Join(productRows, "\n")

	return topRow + alignmentRow + productRowsString
}

func (productData *ProductData) getProductRow(product Product) string {
	priceData := productData.PriceMap[product.ID]

	// make sure this isn't fragile. possibly no guarantees
	discountedPrice := priceData.DiscountedPrice
	discountPercentage, ok := priceData.DiscountText.(string)
	if !ok {
		discountPercentage = "0%"
	}
	basePrice := priceData.BasePrice
	return fmt.Sprintf("%s | %s | %s | %s", product.Name, discountedPrice, discountPercentage, basePrice)
}
